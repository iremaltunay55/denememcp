TITLE: Defining Tool Parameters with Type Annotations (Python)
DESCRIPTION: Illustrates how to use standard Python type annotations (`str`, `int`, `str | None`) to define the expected data types for tool parameters. These annotations are crucial for LLM understanding, client validation, and schema generation.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_1

LANGUAGE: Python
CODE:
```
@mcp.tool()
def analyze_text(
    text: str,
    max_tokens: int = 100,
    language: str | None = None
) -> dict:
    """Analyze the provided text."""
    # Implementation...
```

----------------------------------------

TITLE: Creating a basic FastMCP server with a tool - Python
DESCRIPTION: This snippet demonstrates how to initialize a FastMCP server instance and define a simple tool using the `@mcp.tool()` decorator. The `add` function is registered as an MCP tool. The code also shows how to start the server using `mcp.run()` when the script is executed directly.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/welcome.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP

mcp = FastMCP("Demo ðŸš€")

@mcp.tool()
def add(a: int, b: int) -> int:
    """Add two numbers"""
    return a + b

if __name__ == "__main__":
    mcp.run()
```

----------------------------------------

TITLE: Complete FastMCP Example with OpenAPI Spec - Python
DESCRIPTION: This comprehensive example demonstrates how to initialize and use FastMCP with an OpenAPI specification. It includes defining the spec, creating an `httpx.AsyncClient`, instantiating `FastMCP.from_openapi`, checking the generated tools, resources, and templates, and finally running the MCP server. It requires `asyncio`, `httpx`, and `fastmcp`.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_8

LANGUAGE: python
CODE:
```
import asyncio

import httpx

from fastmcp import FastMCP

# Sample OpenAPI spec for a Pet Store API
petstore_spec = {
    "openapi": "3.0.0",
    "info": {
        "title": "Pet Store API",
        "version": "1.0.0",
        "description": "A sample API for managing pets"
    },
    "paths": {
        "/pets": {
            "get": {
                "operationId": "listPets",
                "summary": "List all pets",
                "responses": {"200": {"description": "A list of pets"}}
            },
            "post": {
                "operationId": "createPet",
                "summary": "Create a new pet",
                "responses": {"201": {"description": "Pet created successfully"}}
            }
        },
        "/pets/{petId}": {
            "get": {
                "operationId": "getPet",
                "summary": "Get a pet by ID",
                "parameters": [
                    {
                        "name": "petId",
                        "in": "path",
                        "required": True,
                        "schema": {"type": "string"}
                    }
                ],
                "responses": {
                    "200": {"description": "Pet details"},
                    "404": {"description": "Pet not found"}
                }
            }
        }
    }
}


async def check_mcp(mcp: FastMCP):
    # List what components were created
    tools = await mcp.get_tools()
    resources = await mcp.get_resources()
    templates = await mcp.get_resource_templates()

    print(
        f"{len(tools)} Tool(s): {', '.join([t.name for t in tools.values()])}"
    )  # Should include createPet
    print(
        f"{len(resources)} Resource(s): {', '.join([r.name for r in resources.values()])}"
    )  # Should include listPets
    print(
        f"{len(templates)} Resource Template(s): {', '.join([t.name for t in templates.values()])}"
    )  # Should include getPet

    return mcp


if __name__ == "__main__":
    # Client for the Pet Store API
    client = httpx.AsyncClient(base_url="https://petstore.example.com/api")

    # Create the MCP server
    mcp = FastMCP.from_openapi(
        openapi_spec=petstore_spec, client=client, name="PetStore"
    )

    asyncio.run(check_mcp(mcp))

    # Start the MCP server
    mcp.run()
```

----------------------------------------

TITLE: Defining a Simple FastMCP Server - Python
DESCRIPTION: This snippet shows how to create a basic FastMCP server instance and register a Python function as an MCP tool using the `@mcp.tool()` decorator. The server is configured to run when the script is executed directly.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_0

LANGUAGE: python
CODE:
```
# server.py
from fastmcp import FastMCP

mcp = FastMCP("Demo ðŸš€")

@mcp.tool()
def add(a: int, b: int) -> int:
    """Add two numbers"""
    return a + b

if __name__ == "__main__":
    mcp.run()
```

----------------------------------------

TITLE: Adding Parameter Metadata and Validation with Annotated and Field (Python)
DESCRIPTION: Shows the preferred method for adding rich metadata and validation rules to tool parameters using Pydantic's `Field` in conjunction with `typing.Annotated`. This allows specifying descriptions, constraints (like `ge`, `le`), and default values.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_2

LANGUAGE: Python
CODE:
```
from typing import Annotated
from pydantic import Field

@mcp.tool()
def process_image(
    image_url: Annotated[str, Field(description="URL of the image to process")],
    resize: Annotated[bool, Field(description="Whether to resize the image")] = False,
    width: Annotated[int, Field(description="Target width in pixels", ge=1, le=2000)] = 800,
    format: Annotated[
        Literal["jpeg", "png", "webp"],
        Field(description="Output image format")
    ] = "jpeg"
) -> dict:
    """Process an image with optional resizing."""
    # Implementation...
```

----------------------------------------

TITLE: Complete FastMCP from FastAPI Example with Pydantic - Python
DESCRIPTION: This complete example integrates a Pydantic data model into a FastAPI application. It demonstrates creating endpoints for listing, getting, and creating items, including error handling with `HTTPException`. The snippet also shows how to use an async function to connect to the generated FastMCP server and list the `Tools`, `Resources`, and `Resource Templates` that FastMCP automatically created based on the FastAPI routes.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/fastapi.mdx#_snippet_2

LANGUAGE: python
CODE:
```
import asyncio
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from fastmcp import FastMCP, Client

# Define your Pydantic model
class Item(BaseModel):
    name: str
    price: float

# Create your FastAPI app
app = FastAPI()
items = {}  # In-memory database

@app.get("/items")
def list_items():
    """List all items"""
    return list(items.values())

@app.get("/items/{item_id}")
def get_item(item_id: int):
    """Get item by ID"""
    if item_id not in items:
        raise HTTPException(404, "Item not found")
    return items[item_id]

@app.post("/items")
def create_item(item: Item):
    """Create a new item"""
    item_id = len(items) + 1
    items[item_id] = {"id": item_id, **item.model_dump()}
    return items[item_id]

# Test your MCP server with a client
async def check_mcp(mcp: FastMCP):
    # List the components that were created
    tools = await mcp.get_tools()
    resources = await mcp.get_resources()
    templates = await mcp.get_resource_templates()

    print(
        f"{len(tools)} Tool(s): {', '.join([t.name for t in tools.values()])}"
    )
    print(
        f"{len(resources)} Resource(s): {', '.join([r.name for r in resources.values()])}"
    )
    print(
        f"{len(templates)} Resource Template(s): {', '.join([t.name for t in templates.values()])}"
    )

    return mcp

if __name__ == "__main__":
    # Create MCP server from FastAPI app
    mcp = FastMCP.from_fastapi(app=app)

    asyncio.run(check_mcp(mcp))

    # In a real scenario, you would run the server:
    # mcp.run()
```

----------------------------------------

TITLE: Creating a Basic FastMCP Tool (Python)
DESCRIPTION: Demonstrates the fundamental way to define a tool in FastMCP by decorating a Python function with `@mcp.tool()`. It shows how the function name, docstring, and type annotations are automatically used for the tool's definition.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_0

LANGUAGE: Python
CODE:
```
from fastmcp import FastMCP

mcp = FastMCP(name="CalculatorServer")

@mcp.tool()
def add(a: int, b: int) -> int:
    """Adds two integer numbers together."""
    return a + b
```

----------------------------------------

TITLE: Defining FastMCP Tool Parameters with Built-in Types (Python)
DESCRIPTION: Demonstrates how to define tool parameters using standard Python built-in scalar types (str, int, float, bool). FastMCP uses these type hints for validation and automatic type coercion from client inputs.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_11

LANGUAGE: python
CODE:
```
@mcp.tool()
def process_values(
    name: str,             # Text data
    count: int,            # Integer numbers
    amount: float,         # Floating point numbers
    enabled: bool          # Boolean values (True/False)
):
    """Process various value types."""
    # Implementation...

```

----------------------------------------

TITLE: Testing FastMCP Server with Client (Python)
DESCRIPTION: Demonstrates how to test a FastMCP server by creating a client instance pointing to the server object. It defines an asynchronous function to call the 'greet' tool and prints the result, using `asyncio.run` to execute the async client call.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_2

LANGUAGE: python
CODE:
```
import asyncio
from fastmcp import FastMCP, Client

mcp = FastMCP("My MCP Server")

@mcp.tool()
def greet(name: str) -> str:
    return f"Hello, {name}!"

client = Client(mcp)

async def call_tool(name: str):
    async with client:
        result = await client.call_tool("greet", {"name": name})
        print(result)

asyncio.run(call_tool("Ford"))
```

----------------------------------------

TITLE: Mounting FastMCP in FastAPI
DESCRIPTION: Illustrates how to mount a FastMCP server within a FastAPI application. It involves creating the FastMCP server and its ASGI app, then mounting the MCP app onto a path in the main FastAPI application, highlighting the necessity of passing the FastMCP app's lifespan to the FastAPI app.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/deployment/asgi.mdx#_snippet_8

LANGUAGE: Python
CODE:
```
from fastmcp import FastMCP
from fastapi import FastAPI
from starlette.routing import Mount

# Create your FastMCP server as well as any tools, resources, etc.
mcp = FastMCP("MyServer")

# Create the ASGI app
mcp_app = mcp.http_app(path='/mcp')

# Create a FastAPI app and mount the MCP server
app = FastAPI(lifespan=mcp_app.lifespan)
app.mount("/mcp-server", mcp_app)
```

----------------------------------------

TITLE: Analyze Sentiment using FastMCP LLM (Python)
DESCRIPTION: This snippet defines a FastMCP tool that uses the `ctx.sample` method to send a text analysis prompt to the client's LLM. It processes the LLM's response to determine sentiment (positive, negative, or neutral) and returns the result. It requires the `Context` object.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_7

LANGUAGE: python
CODE:
```
@mcp.tool()
async def analyze_sentiment(text: str, ctx: Context) -> dict:
    """Analyze the sentiment of a text using the client's LLM."""
    # Create a sampling prompt asking for sentiment analysis
    prompt = f"Analyze the sentiment of the following text as positive, negative, or neutral. Just output a single word - 'positive', 'negative', or 'neutral'. Text to analyze: {text}"
    
    # Send the sampling request to the client's LLM
    response = await ctx.sample(prompt)
    
    # Process the LLM's response
    sentiment = response.text.strip().lower()
    
    # Map to standard sentiment values
    if "positive" in sentiment:
        sentiment = "positive"
    elif "negative" in sentiment:
        sentiment = "negative"
    else:
        sentiment = "neutral"
    
    return {"text": text, "sentiment": sentiment}
```

----------------------------------------

TITLE: Defining a Tool with FastMCP
DESCRIPTION: Shows how to register a Python function as a callable tool for the client using the `@mcp.tool()` decorator. The function signature defines the tool's parameters and return type.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/fastmcp.mdx#_snippet_1

LANGUAGE: python
CODE:
```
@mcp.tool()
def multiply(a: float, b: float) -> float:
    """Multiplies two numbers together."""
    return a * b
```

----------------------------------------

TITLE: Define Static Resource with @mcp.resource()
DESCRIPTION: Decorate a Python function with `@mcp.resource("your://uri")` to expose read-only data at a specific URI. This example shows a static resource returning a fixed value.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_5

LANGUAGE: python
CODE:
```
# Static resource
@mcp.resource("config://version")
def get_version(): 
    return "2.0.1"
```

----------------------------------------

TITLE: Running FastMCP Server with Python run() Method
DESCRIPTION: Demonstrates how to initialize a FastMCP server instance and run it directly from a Python script using the run() method. It includes a simple tool definition and shows the recommended if __name__ == "__main__": block for ensuring the server starts only when the script is executed directly.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/deployment/running-server.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP

mcp = FastMCP(name="MyServer")

@mcp.tool()
def hello(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    mcp.run()
```

----------------------------------------

TITLE: Using Type Annotations and Pydantic Fields for Prompts with FastMCP Python
DESCRIPTION: Shows how to use Python type annotations (`str`, `Literal`, `Optional`, `int`) and Pydantic's `Field` for parameter validation and schema generation. The function constructs a prompt string based on the validated inputs, including optional parameters. Requires `Field`, `Literal`, and `Optional`.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_2

LANGUAGE: python
CODE:
```
from pydantic import Field
from typing import Literal, Optional

@mcp.prompt()
def generate_content_request(
    topic: str = Field(description="The main subject to cover"),
    format: Literal["blog", "email", "social"] = "blog",
    tone: str = "professional",
    word_count: Optional[int] = None
) -> str:
    """Create a request for generating content in a specific format."""
    prompt = f"Please write a {format} post about {topic} in a {tone} tone."
    
    if word_count:
        prompt += f" It should be approximately {word_count} words long."
        
    return prompt
```

----------------------------------------

TITLE: Mapping All OpenAPI Routes as Tools in FastMCP (Python)
DESCRIPTION: Shows how to use the `all_routes_as_tools` parameter when initializing FastMCP from OpenAPI. Setting this parameter to `True` forces every route defined in the OpenAPI specification to be mapped as an MCP Tool, which is useful for AI agent backends.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/openapi.mdx#_snippet_4

LANGUAGE: python
CODE:
```
# Make all endpoints tools, regardless of HTTP method
mcp = FastMCP.from_openapi(
    openapi_spec=spec,
    client=api_client,
    all_routes_as_tools=True
)
```

----------------------------------------

TITLE: Generate Code Example using FastMCP LLM (Python)
DESCRIPTION: This FastMCP tool demonstrates using `ctx.sample` with both a user message and a system prompt to guide the LLM's response. It also shows how to set optional parameters like `temperature` and `max_tokens` when requesting text generation. It requires the `Context` object.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_8

LANGUAGE: python
CODE:
```
@mcp.tool()
async def generate_example(concept: str, ctx: Context) -> str:
    """Generate a Python code example for a given concept."""
    # Using a system prompt and a user message
    response = await ctx.sample(
        messages=f"Write a simple Python code example demonstrating '{concept}'.",
        system_prompt="You are an expert Python programmer. Provide concise, working code examples without explanations.",
        temperature=0.7,
        max_tokens=300
    )
    
    code_example = response.text
    return f"```python\n{code_example}\n```"
```

----------------------------------------

TITLE: Initializing FastMCP Server from Basic FastAPI App - Python
DESCRIPTION: This snippet shows how to create a basic FastAPI application with simple GET and POST endpoints. It then demonstrates how to leverage the `FastMCP.from_fastapi` method to convert this FastAPI app into a FastMCP server. The `if __name__ == "__main__": mcp.run()` block illustrates how to start the generated MCP server.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/fastapi.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastapi import FastAPI
from fastmcp import FastMCP


# A FastAPI app
app = FastAPI()

@app.get("/items")
def list_items():
    return [{"id": 1, "name": "Item 1"}, {"id": 2, "name": "Item 2"}]

@app.get("/items/{item_id}")
def get_item(item_id: int):
    return {"id": item_id, "name": f"Item {item_id}"}

@app.post("/items")
def create_item(name: str):
    return {"id": 3, "name": name}


# Create an MCP server from your FastAPI app
mcp = FastMCP.from_fastapi(app=app)

if __name__ == "__main__":
    mcp.run()  # Start the MCP server
```

----------------------------------------

TITLE: Adding Tool to FastMCP Server (Python)
DESCRIPTION: Adds a simple tool named `greet` to the FastMCP server instance. The tool is a Python function decorated with `@mcp.tool()` that takes a string `name` and returns a greeting string.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_1

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP

mcp = FastMCP("My MCP Server")

@mcp.tool()
def greet(name: str) -> str:
    return f"Hello, {name}!"
```

----------------------------------------

TITLE: Configuring Client Timeouts in Python
DESCRIPTION: Demonstrates initializing a fastmcp client with a default global timeout and overriding this timeout for specific tool calls. It also shows how to catch and handle timeout errors using a try...except block.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_10

LANGUAGE: python
CODE:
```
client = Client(
    my_mcp_server,
    timeout=5.0  # Default timeout in seconds
)

async with client:
    # This uses the global 5-second timeout
    result1 = await client.call_tool("quick_task", {"param": "value"})

    # This specifies a 10-second timeout for this specific call
    result2 = await client.call_tool("slow_task", {"param": "value"}, timeout=10.0)

    try:
        # This will likely timeout
        result3 = await client.call_tool("medium_task", {"param": "value"}, timeout=0.01)
    except McpError as e:
        # Handle timeout error
        print(f"The task timed out: {e}")
```

----------------------------------------

TITLE: Defining Basic Prompts with FastMCP Python
DESCRIPTION: Shows how to use the `@mcp.prompt` decorator on Python functions. The first example returns a string, automatically converted to a user message. The second explicitly returns a `PromptMessage` object, demonstrating how to set the role and content type. Requires `FastMCP` and prompt-related classes.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP
from fastmcp.prompts.prompt import Message, PromptMessage, TextContent

mcp = FastMCP(name="PromptServer")

# Basic prompt returning a string (converted to user message automatically)
@mcp.prompt()
def ask_about_topic(topic: str) -> str:
    """Generates a user message asking for an explanation of a topic."""
    return f"Can you please explain the concept of '{topic}'?"

# Prompt returning a specific message type
@mcp.prompt()
def generate_code_request(language: str, task_description: str) -> PromptMessage:
    """Generates a user message requesting code generation."""
    content = f"Write a {language} function that performs the following task: {task_description}"
    return PromptMessage(role="user", content=TextContent(type="text", text=content))
```

----------------------------------------

TITLE: Connecting to FastMCP Servers with Client (Python)
DESCRIPTION: Shows how to use the `fastmcp.Client` to connect to an MCP server programmatically. Illustrates connecting via Stdio to a local script and via SSE to an HTTP endpoint. Requires the `fastmcp` library.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_9

LANGUAGE: python
CODE:
```
from fastmcp import Client

async def main():
    # Connect via stdio to a local script
    async with Client("my_server.py") as client:
        tools = await client.list_tools()
        print(f"Available tools: {tools}")
        result = await client.call_tool("add", {"a": 5, "b": 3})
        print(f"Result: {result.text}")

    # Connect via SSE
    async with Client("http://localhost:8000/sse") as client:
        # ... use the client
        pass
```

----------------------------------------

TITLE: Define a Tool with @mcp.tool()
DESCRIPTION: Decorate a Python function with `@mcp.tool()` to expose it as an executable tool for LLMs. FastMCP handles schema generation from type hints and docstrings. Tools can return various data types.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_4

LANGUAGE: python
CODE:
```
@mcp.tool()
def multiply(a: float, b: float) -> float:
    """Multiplies two numbers."""
    return a * b
```

----------------------------------------

TITLE: Define a Prompt with @mcp.prompt()
DESCRIPTION: Decorate a Python function with `@mcp.prompt()` to define reusable message templates for guiding LLM interactions. The function should return a string or a Message object.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_7

LANGUAGE: python
CODE:
```
@mcp.prompt()
def summarize_request(text: str) -> str:
    """Generate a prompt asking for a summary."""
    return f"Please summarize the following text:\n\n{text}"
```

----------------------------------------

TITLE: Calling a Tool (Python)
DESCRIPTION: Executes a specific tool on the server by name, optionally passing arguments. Demonstrates basic usage, using a timeout, and using a progress handler.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_4

LANGUAGE: python
CODE:
```
result = await client.call_tool("add", {"a": 5, "b": 3})
# result -> list[mcp.types.TextContent | mcp.types.ImageContent | ...]
print(result[0].text) # Assuming TextContent, e.g., '8'
```

LANGUAGE: python
CODE:
```
# With timeout (aborts if execution takes longer than 2 seconds)
result = await client.call_tool("long_running_task", {"param": "value"}, timeout=2.0)
```

LANGUAGE: python
CODE:
```
# With progress handler (to track execution progress)
result = await client.call_tool(
    "long_running_task",
    {"param": "value"},
    progress_handler=my_progress_handler
)
```

----------------------------------------

TITLE: Running FastMCP Server with Streamable HTTP Transport (Python)
DESCRIPTION: Demonstrates configuring a FastMCP server to run using the Streamable HTTP transport, which is recommended for web deployments. This involves specifying the transport type, host address, port number, and optional path in the `mcp.run()` method. Requires the `fastmcp` library.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_13

LANGUAGE: python
CODE:
```
mcp.run(transport="streamable-http", host="127.0.0.1", port=8000, path="/mcp")
```

----------------------------------------

TITLE: Implementing Synchronous and Asynchronous FastMCP Tools in Python
DESCRIPTION: FastMCP supports both standard synchronous (`def`) and asynchronous (`async def`) functions as tools. Use `async def` for I/O-bound operations like network requests or database calls to prevent blocking the server.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_6

LANGUAGE: python
CODE:
```
# Synchronous tool (suitable for CPU-bound or quick tasks)
@mcp.tool()
def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """Calculate the distance between two coordinates."""
    # Implementation...
    return 42.5

# Asynchronous tool (ideal for I/O-bound operations)
@mcp.tool()
async def fetch_weather(city: str) -> dict:
    """Retrieve current weather conditions for a city."""
    # Use 'async def' for operations involving network calls, file I/O, etc.
    # This prevents blocking the server while waiting for external operations.
    async with aiohttp.ClientSession() as session:
        async with session.get(f"https://api.example.com/weather/{city}") as response:
            # Check response status before returning
            response.raise_for_status()
            return await response.json()
```

----------------------------------------

TITLE: Define FastMCP Tool with Context Injection (Python)
DESCRIPTION: Demonstrates how to define a FastMCP tool function that receives the `Context` object via dependency injection. The `ctx` parameter is type-hinted as `Context`, allowing the function to access MCP capabilities like logging and resource access during execution.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP, Context

mcp = FastMCP(name="ContextDemo")

@mcp.tool()
async def process_file(file_uri: str, ctx: Context) -> str:
    """Processes a file, using context for logging and resource access."""
    # Context is available as the ctx parameter
    return "Processed file"
```

----------------------------------------

TITLE: Testing FastMCP Server Tool with In-Memory Client (Python)
DESCRIPTION: This snippet demonstrates how to perform in-memory testing of a FastMCP server's tool function using pytest. It shows how to create a server instance with a tool, pass the server directly to a Client, call the tool, and assert the result.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/testing.mdx#_snippet_0

LANGUAGE: python
CODE:
```
import pytest
from fastmcp import FastMCP, Client

@pytest.fixture
def mcp_server():
    server = FastMCP("TestServer")

    @server.tool()
    def greet(name: str) -> str:
        return f"Hello, {name}!"

    return server

async def test_tool_functionality(mcp_server):
    # Pass the server directly to the Client constructor
    async with Client(mcp_server) as client:
        result = await client.call_tool("greet", {"name": "World"})
        assert result[0].text == "Hello, World!"
```

----------------------------------------

TITLE: Accessing HTTP Request in FastMCP Tool (Python)
DESCRIPTION: Demonstrates how to use the `get_http_request()` dependency function within a FastMCP tool to obtain the underlying Starlette Request object. This allows access to request details like headers, client information, and URL path. Requires `fastmcp`, `fastmcp.server.dependencies.get_http_request`, and `starlette.requests.Request`.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/patterns/http-requests.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_request
from starlette.requests import Request

mcp = FastMCP(name="HTTPRequestDemo")

@mcp.tool()
async def user_agent_info() -> dict:
    """Return information about the user agent."""
    # Get the HTTP request
    request: Request = get_http_request()
    
    # Access request data
    user_agent = request.headers.get("user-agent", "Unknown")
    client_ip = request.client.host if request.client else "Unknown"
    
    return {
        "user_agent": user_agent,
        "client_ip": client_ip,
        "path": request.url.path,
    }
```

----------------------------------------

TITLE: Interacting with FastMCP Server File (Python)
DESCRIPTION: Shows how to create a FastMCP client that connects to a server defined in a separate Python file (`my_server.py`). It uses asyncio to call the 'greet' tool on the server and print the response.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/getting-started/quickstart.mdx#_snippet_4

LANGUAGE: python
CODE:
```
import asyncio
from fastmcp import Client

client = Client("my_server.py")

async def call_tool(name: str):
    async with client:
        result = await client.call_tool("greet", {"name": name})
        print(result)

asyncio.run(call_tool("Ford"))
```

----------------------------------------

TITLE: Access Context via Dependency Function (Python)
DESCRIPTION: Demonstrates how to retrieve the active `Context` object using the `get_context()` dependency function. This method is useful for accessing context in utility functions or nested code that doesn't receive context via parameter injection. It emphasizes that this only works within a server request context.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/context.mdx#_snippet_3

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP, Context
from fastmcp.server.dependencies import get_context

mcp = FastMCP(name="DependencyDemo")

# Utility function that needs context but doesn't receive it as a parameter
async def process_data(data: list[float]) -> dict:
    # Get the active context - only works when called within a request
    ctx = get_context()    
    await ctx.info(f"Processing {len(data)} data points")
    
@mcp.tool()
async def analyze_dataset(dataset_name: str) -> dict:
    # Call utility function that uses context internally
    data = load_data(dataset_name)
    await process_data(data)
```

----------------------------------------

TITLE: Adding Custom Health Check Route to FastMCP Server (Python)
DESCRIPTION: This snippet demonstrates how to add a custom GET route '/health' to a FastMCP server using the `@mcp.custom_route` decorator. It imports necessary components from `fastmcp` and `starlette` to define an asynchronous function that handles requests to this route and returns a simple 'OK' plain text response.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/deployment/running-server.mdx#_snippet_5

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP
from starlette.requests import Request
from starlette.responses import PlainTextResponse

mcp = FastMCP("MyServer")

@mcp.custom_route("/health", methods=["GET"])
async def health_check(request: Request) -> PlainTextResponse:
    return PlainTextResponse("OK")

if __name__ == "__main__":
    mcp.run()
```

----------------------------------------

TITLE: Accessing MCP Context in Prompts (Python)
DESCRIPTION: Prompts can access additional information and features provided by the FastMCP server through the `Context` object. This is achieved by adding a parameter to the prompt function with a type annotation of `Context`.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/prompts.mdx#_snippet_6

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP, Context

mcp = FastMCP(name="PromptServer")

@mcp.prompt()
async def generate_report_request(report_type: str, ctx: Context) -> str:
    """Generates a request for a report."""
    return f"Please create a {report_type} report. Request ID: {ctx.request_id}"
```

----------------------------------------

TITLE: Using Context Object in FastMCP Tool (Python)
DESCRIPTION: Demonstrates how to access MCP features like logging, resource reading, progress reporting, and LLM sampling within a FastMCP tool function by adding a Context parameter. It shows examples of ctx.info, ctx.read_resource, ctx.report_progress, and ctx.sample.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_10

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP, Context

mcp = FastMCP(name="ContextDemo")

@mcp.tool()
async def process_data(data_uri: str, ctx: Context) -> dict:
    """Process data from a resource with progress reporting."""
    await ctx.info(f"Processing data from {data_uri}")
    
    # Read a resource
    resource = await ctx.read_resource(data_uri)
    data = resource[0].content if resource else ""
    
    # Report progress
    await ctx.report_progress(progress=50, total=100)
    
    # Example request to the client's LLM for help
    summary = await ctx.sample(f"Summarize this in 10 words: {data[:200]}")
    
    await ctx.report_progress(progress=100, total=100)
    return {
        "length": len(data),
        "summary": summary.text
    }
```

----------------------------------------

TITLE: Creating FastMCP ASGI App (http_app/sse_app) - Python
DESCRIPTION: Demonstrates how to initialize a FastMCP server, define a tool, and obtain ASGI application instances for both Streamable HTTP (`http_app`) and legacy SSE (`sse_app`) transports using the `http_app()` method.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/deployment/asgi.mdx#_snippet_0

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP

mcp = FastMCP("MyServer")

@mcp.tool()
def hello(name: str) -> str:
    return f"Hello, {name}!"

# Get a Starlette app instance for Streamable HTTP transport (recommended)
http_app = mcp.http_app()

# For legacy SSE transport (deprecated)
sse_app = mcp.http_app(transport="sse")
```

----------------------------------------

TITLE: Defining Optional Parameters in FastMCP Python
DESCRIPTION: FastMCP tools follow standard Python parameter conventions. Parameters without default values are required, while those with default values or annotated with `| None` are considered optional. This snippet demonstrates a tool with both required and optional parameters.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_4

LANGUAGE: python
CODE:
```
@mcp.tool()
def search_products(
    query: str,                   # Required - no default value
    max_results: int = 10,        # Optional - has default value
    sort_by: str = "relevance",   # Optional - has default value
    category: str | None = None   # Optional - can be None
) -> list[dict]:
    """Search the product catalog."""
    # Implementation...
```

----------------------------------------

TITLE: Reading Resource Content (Python)
DESCRIPTION: Reads the content of a specific resource identified by its URI. Can be used for static resources or resources generated from templates.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_7

LANGUAGE: python
CODE:
```
# Read a static resource
readme_content = await client.read_resource("file:///path/to/README.md")
# readme_content -> list[mcp.types.TextResourceContents | mcp.types.BlobResourceContents]
print(readme_content[0].text) # Assuming text
```

LANGUAGE: python
CODE:
```
# Read a resource generated from a template
weather_content = await client.read_resource("data://weather/london")
print(weather_content[0].text) # Assuming text JSON
```

----------------------------------------

TITLE: Setting Custom Path for FastMCP ASGI App - Python
DESCRIPTION: Shows how to specify a custom URL path for the FastMCP server endpoint when creating the ASGI application instance using the `http_app()` method for both Streamable HTTP and SSE transports.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/deployment/asgi.mdx#_snippet_1

LANGUAGE: python
CODE:
```
# For Streamable HTTP transport
http_app = mcp.http_app(path="/custom-mcp-path")

# For SSE transport (deprecated)
sse_app = mcp.http_app(path="/custom-sse-path", transport="sse")
```

----------------------------------------

TITLE: Using Context in a FastMCP Tool (Python)
DESCRIPTION: Demonstrates how to access and use the `Context` object within a FastMCP tool function, showing examples of logging messages to the client, reading resources from the server, and requesting LLM completions. Requires the `fastmcp` library.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/README.md#_snippet_8

LANGUAGE: python
CODE:
```
from fastmcp import FastMCP, Context

mcp = FastMCP("My MCP Server")

@mcp.tool()
async def process_data(uri: str, ctx: Context):
    # Log a message to the client
    await ctx.info(f"Processing {uri}...")

    # Read a resource from the server
    data = await ctx.read_resource(uri)

    # Ask client LLM to summarize the data
    summary = await ctx.sample(f"Summarize: {data.content[:500]}")

    # Return the summary
    return summary.text
```

----------------------------------------

TITLE: Initializing FastMCP Client with Various Transports (Python)
DESCRIPTION: Demonstrates how to initialize the `FastMCP.Client` by providing different types of transport sources (an in-memory server instance, HTTP/WebSocket URLs, or a path to a script), showcasing the client's ability to automatically infer and configure the appropriate transport mechanism based on the input type.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/client.mdx#_snippet_1

LANGUAGE: python
CODE:
```
import asyncio
from fastmcp import Client, FastMCP

# Example transports (more details in Transports page)
server_instance = FastMCP(name="TestServer") # In-memory server
http_url = "https://example.com/mcp"        # HTTP server URL
ws_url = "ws://localhost:9000"             # WebSocket server URL
server_script = "my_mcp_server.py"         # Path to a Python server file

# Client automatically infers the transport type
client_in_memory = Client(server_instance)
client_http = Client(http_url)
client_ws = Client(ws_url)
client_stdio = Client(server_script)

print(client_in_memory.transport)
print(client_http.transport)
print(client_ws.transport)
print(client_stdio.transport)

# Expected Output (types may vary slightly based on environment):
# <FastMCP(server='TestServer')>
# <StreamableHttp(url='https://example.com/mcp')>
# <WebSocket(url='ws://localhost:9000')>
# <PythonStdioTransport(command='python', args=['/path/to/your/my_mcp_server.py'])>
```

----------------------------------------

TITLE: Defining Flexible Parameters with Union and Optional Types (Python)
DESCRIPTION: Demonstrates using modern Python type hints (`|` operator) for parameters that can accept multiple types (like `str | int`) or are optional (`Type | None`). This approach is preferred over older `typing.Union` and `typing.Optional` forms.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/servers/tools.mdx#_snippet_14

LANGUAGE: python
CODE:
```
@mcp.tool()
def flexible_search(
    query: str | int,              # Can be either string or integer
    filters: dict[str, str] | None = None,  # Optional dictionary
    sort_field: str | None = None  # Optional string
):
    """Search with flexible parameter types."""
    # Implementation...

```

----------------------------------------

TITLE: Creating Client and Calling Tool (Python)
DESCRIPTION: Creates a FastMCP client connected directly to the server instance, automatically inferring the in-memory transport. Defines an asynchronous `main` function to call the 'ping' tool on the server and print the result, demonstrating client-side interaction.
SOURCE: https://github.com/jlowin/fastmcp/blob/main/docs/clients/transports.mdx#_snippet_12

LANGUAGE: Python
CODE:
```
client = Client(server) # Transport is automatically inferred

async def main():
    async with client:
        result = await client.call_tool("ping")
        print(f"In-memory call result: {result}")

asyncio.run(main())
```